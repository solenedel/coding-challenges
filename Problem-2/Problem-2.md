# Robot in a square grid

## Layout of the problem and solution

Of course, the robot doesn't have any knowledge of the size of the grid (9x9 squares), otherwise it would be able to calculate the number of rooms in one step. The robot must visit each room in order to count the total number of rooms in the grid. However, it does not need to open all closed doors in order to visit and therefore count every room. 

Even though the robot itself has no knowledge of the size of the grid, the program that simulates this game should be able to generate the 9x9 grid, along with which walls have open doors, closed doors, and which have no doors. This way, the robot can check the walls against the grid generated by the program, even if the values corresponding to the number of rows and columns of the grid cannot be used by the robot itself.

The general steps to implement this problem would be:

## Part 1: Generating the grid

The grid can be represented as an array of length 81 (9x9). Each element of the array is an object which represents a single room. 

General structure of the `grid` array:
```
[ {}, {}, {}, ... ]
```

An example of what one element would look like:
```
{
  coordinates: [1, 1], 
  visited: true,
  walls: ['closed', 'closed', 'none', 'none']
}
```
The above object represents the room the robot starts in: the lower right corner of the grid. The `coordinates` property represents the location of the room in relation to the rest of the grid. The values range from `[1, 1]` to `[9, 9]`. Note that these are coordinates of the rooms themselves, and not the walls/edges of the room. Thus there is no room at `[0, 0]`.

The `visited` property is true if the robot has visited the room and false otherwise. It follows that if `visited` is true, then that room has been counted by the robot. 

The `walls` property is an array of four strings, each one representing the state of the wall in a particular direction. The directions are ordered starting at North, and going in the counterclockwise direction. Therefore: 

```
walls[0] = North
walls[1] = West
walls[2] = South 
walls[3] = East
```
The values `open`, `closed` and `none` represent the state of each wall/door. When the `grid` array is generated by the program, all values begin as `closed`, with exceptions for rooms on the edge of the squares, which have values of `none` in some directions. Corner rooms would have two `none` values, and other edge rooms would have one `none` value.



## Step 2: Defining the robot's actions

Variables to keep track of in relation to the robot:

```
robotLocation = [column, row]
roomCount = INTEGER
cornerRoomsVisited = INTEGER (maximum 4)
```

The `robotLocation` variable starts at `[1, 1]` and `roomCount` starts at `1` to represent the room the robot starts in. 

The robot has a function `checkWalls` which determines whether the robot can/should move to an adjacent room, and moves into it, incrementing the `roomCount` variable.

The `cornerRoomsVisited` variable is how the robot checks whether or not it has counted all the rooms. Corner rooms have two `none` values in the `walls` array, so whenever this criterion is met, the `cornerRoomsVisited` count will be incremented by 1. When this count reaches 4 and the current room has been counted, the robot will know to stop looking for new rooms. 

```
const checkWalls = (robotLocation, roomCount) {

  // find the element in the grid array that matches the coordinates of robotLocation. Referred to as grid[i]

  // start scanning the walls in counter clockwise direction. This uses a recursive function.

  // base case: door is initially closed AND room with coordinates on the other size is not visited
  if ( grid[i].walls[0] === )


}
```
NOTE: when one door of a room is changed from closed to open, the same change must ba epplied to the adjacent room on the other side of the door.

## To check: 

It may not be necessary to check the 'visited' status of the adjacent room before deciding whether or not to open a closed door. because the directions are always looped through in the same order, the robot will follow the same S-shaped pattern when navigating through the grid. Thus, even if a closed door has an open room on the other side, the robot will not reach the scenario where it has to face a closed door with an open door on the other side.

How does the robot know when it has counted all the rooms? It can't access the total number of rooms. Perhaps we need a variable to keep track of how many corner rooms the robot has visited. When that count reaches 4, it will be the last room because the last visited room will always be a corner room. 

If the robot does not know the size of the grid, how can it have access to its current location as coordinates? If it starts at [1, 1]  then this is not an issue, but what if it started at a different location? 

We can assume that the robot can access its current location, but still have no idea how large the grid is. For example if it started at [3, 5] then it would know that the grid is at least 3x5 squares large, but it would not know the upper limits. 

## Further notes
- what if the grid size changes?
- would it also work for a rectangular grid?
- would it work with any starting point for the robot?
