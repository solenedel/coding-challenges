# ðŸ¤– Robot in a square grid ðŸ¤–

## Assumptions

1. The robot must visit each room in order to count the total number of rooms (ie. the robot cannot use length * width of the grid in order to calculate the number of rooms).

2. The robot has access to its starting coordinates (the room it starts in). When it starts at the bottom right corner, this is room [1, 1]. If the robot starts in a random room of the grid, for example the room at [3, 5] - it is aware of these coordinates but has no further information about the total size of the grid. 


## Generating the grid

Even though the robot itself has no knowledge of the size of the grid, the program that simulates this game should be able to generate the 9x9 grid, along with which walls have open doors, closed doors, and which have no doors. This way, the robot can check the walls of the grid generated by the program, even if the values corresponding to the total number of rows and columns of the grid cannot be used by the robot itself.

General structure of `grid`:
```
{ '1, 1': {}, '2, 1': {}, '3, 1': {}, ... }
```
Each object inside `grid` represents a single room. 

The following is a simplified code snippet for how the program would generate the grid. (the more exact version of the code would have some edge cases corresponding to the edges and corners of the grid, which have some `none` values in the `walls` array.) 

```
let grid = {};

for (let i = 1; i < 10; i++) {
  for (let j = 1; j < 10; j++) {
    grid[[i, j]] = {
      coordinates: [i, j], 
      visited: false,
      walls: ['closed', 'closed', 'closed', 'closed']
    };
  } 
}
```
An example of what one element would look like:
```
{
  coordinates: [1, 1], 
  visited: true,
  walls: ['closed', 'closed', 'none', 'none']
}
```

The above object represents the the lower right corner of the grid. The `coordinates` property represents the location of the room in relation to the rest of the grid. The values range from `[1, 1]` to `[9, 9]`. Note that these are coordinates of the rooms themselves, and not the walls/edges of the room. Thus there is no room at `[0, 0]`.

The `visited` property is `true` if the robot has visited the room and `false` otherwise. It follows that if `visited` is true, then that room has been counted by the robot. 

The `walls` property is an array of four strings, each one representing the state of the wall in a particular direction. The directions are ordered starting at North, and going in the counterclockwise direction. Therefore: 

```
walls[0] = North
walls[1] = West
walls[2] = South 
walls[3] = East
```

The values `open`, `closed` and `none` represent the state of each wall/door. When the `grid` structure is generated by the program, all values begin as `closed`, with exceptions for rooms on the outer edge of the grid, which have values of `none` in some directions. Corner rooms would have two `none` values, and other edge rooms would have one `none` value.

A room with specific coordinates can be looked up like so: `console.log(grid[[5,5]]);` 

This returns:
```
{
  coordinates: [ 5, 5 ],
  visited: false,
  walls: [ 'closed', 'closed', 'closed', 'closed' ]
}
``` 

## Completing the game

How does the robot know when all rooms are counted? The robot moves room by room and cannot "jump" to a room that is not directly adjacent to it. There will always be at least one adjacent room that has not yet been visited, EXCEPT when the robot is in the final room. Thus, when the robot is in a location where all adjacent rooms have the `visited: true` status, it will know that it has counted all rooms.

Note that for the least number of steps, each room should only be visited once. Thus, not all doors should be opened for all rooms to be counted. A door on one side of the wall may be closed even if the room on the other side has been visited, depending on the path taken by the robot. To make sure that each room is only visited once, the robot should check the `visited` status of the room on the other side of a closed door before choosing to open the door. The door should only be opened if the room on the other side has `visited: false`. Otherwise, it should carry on with the wall in the next direction. 


## Defining the robot's actions

The robot keeps track of the following variables:

```
currentLocation = [column, row] 
roomCount = INTEGER
```

The `currentLocation` variable starts at the coordinates of robot at the start of the game. `roomCount` starts at `1` to because the robot starts the game already inside a room.

NOTE: when the status of one wall of a room is changed from `closed` to `open`, the same change must be applied to the adjacent room on the other side of the door. For example if the robot has just opened the North door of a room and moved into the next room, the new room's South door must now be marked as `open`.

## Steps taken by the robot


The program is initiated by `startGame`, which calls the function `checkWalls` that contains the majority of the actions and is a recursive function. Once all rooms have been visited, this is the base case for `checkWalls`. The recursion stops, the function returns `roomCount` and exits the program.

```

const checkWalls = (currentLocation) => {

    // For currentRoomObject:
    // iterate through walls[i] starting at i = 0 (North) and ending at i = 3 (East)
    // if walls[i] is already open or is none, move on to the next direction (i++)
    // if walls[i] is closed AND the room on the other side of the wall has visited: false, then:
      // change the status of walls[i] in the currentRoomObject to open
      // change the status of the corresponding wall in the next room to open
      // change the robot's currentLocation to have the coordinates of the next room
      // change the status of the status of this new room to visited: true
      // increment roomCount by one (roomCount ++)
      // get the new currentRoomObject by looking up the new coordinates in the grid structure

    // check whether all adjacent rooms have visited: true, by looping through walls[i]

      // BASE CASE: all adjacent rooms have visited: true, 
      // return roomCount (the total number of rooms)

      // RECURSIVE CASE: at least one adjacent room has visited: false, 
      // call checkWalls() with the new currentLocation
      // return checkWalls(currentLocation)

  };
  
const startGame = (currentLocation) => {

  // ONLY EXECUTE ONCE PER GAME:
  // lookup the room object corresponding to the currentLocation (the starting location).
  // this room object will be referred to as `currentRoomObject`
  // change `visited` status of starting room object to true
  
  // call checkWalls to perform the rest of the robot's actions
  return checkWalls(currentLocation);
};

```


QUESTIONS: 

**1. The robot starts at the lower right corner of the grid. How can the robot use its abilities to count the total number of rooms in the grid?**

Answered above. The `countRooms` variable returned by `startGame()` contains the total number of rooms counted by the robot. 


**2. The game resets and the robot moves to a random room in the grid. Does your approach still work?**

Yes. The pattern in which the robot moves will be different, but each room will still only be visited once. 

EXTRA CREDIT:

**3. How many moves does it take to complete the count? Can you find the answer in less moves?**

It should take exactly as many moves as there are rooms in the grid. So for the 9*9 grid, it would take 81 moves. It could not take less moves than that, because one of the assumptions was that the robot must visit a room in order for that room to be counted. 

**4. How much data did you save from each move? Can you save less data?**

Items stored in memory will be: 

- the `grid` structure: generated at the start of the program. It will not change size throughout the game- only values will be updated inside the various room objects. 

- the `currentLocation` array: this will be updated as the robot changes room, but the size of the array will not change. 

- the `roomCount` variable: this is an integer that will be incremented by one each time a new room is counted. In the case of a 9x9 grid, it will start as ingeger `1` and end as `81`. This integer variable occupies a constant amount of memory throughout the program.

The memory usage of the program will not increase as the robot counts more squares. With this particular solution for the game, I can't think of a way to save less data. 
