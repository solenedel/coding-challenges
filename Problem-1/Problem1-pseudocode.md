# Robot in a square grid

## Assumptions

1. The robot must visit each room in order to count the total number of rooms (ie. the robot cannot use length * width of the grid in order to calculate the number of rooms).

2. The robot has access to its starting coordinates (the room it starts in). When it starts at the bottom right corner, this is room [1, 1]. If the robot starts in a random room of the grid, for example the room at [3, 5] - it is aware of these coordinates but has no further information about the total size of the grid. 


## Generating the grid

Even though the robot itself has no knowledge of the size of the grid, the program that simulates this game should be able to generate the 9x9 grid, along with which walls have open doors, closed doors, and which have no doors. This way, the robot can check the walls of the grid generated by the program, even if the values corresponding to the total number of rows and columns of the grid cannot be used by the robot itself.

The grid is represented as an array of length 81 (9x9). Each element of the array is an object which represents a single room. 

General structure of the `grid` array:
```
[ {}, {}, {}, ... ]
```

An example of what one element would look like:
```
{
  coordinates: [1, 1], 
  visited: true,
  walls: ['closed', 'closed', 'none', 'none']
}
```
The above object represents the the lower right corner of the grid. The `coordinates` property represents the location of the room in relation to the rest of the grid. The values range from `[1, 1]` to `[9, 9]`. Note that these are coordinates of the rooms themselves, and not the walls/edges of the room. Thus there is no room at `[0, 0]`.

The `visited` property is true if the robot has visited the room and false otherwise. It follows that if `visited` is true, then that room has been counted by the robot. 

The `walls` property is an array of four strings, each one representing the state of the wall in a particular direction. The directions are ordered starting at North, and going in the counterclockwise direction. Therefore: 

```
walls[0] = North
walls[1] = West
walls[2] = South 
walls[3] = East
```
The values `open`, `closed` and `none` represent the state of each wall/door. When the `grid` array is generated by the program, all values begin as `closed`, with exceptions for rooms on the edge of the squares, which have values of `none` in some directions. Corner rooms would have two `none` values, and other edge rooms would have one `none` value.


## Completing the game

How does the robot know when all rooms are counted? The robot moves room by room and cannot "jump" to a room that is not directly adjacent to it. there will always be at least one adjacent room that has not yet been visited, EXCEPT when the robot is in the final room. Thus, when the robot is in a location where all adjacent rooms have the `visited: true` status, it will know that it has counted all rooms.

Note that for the least number of steps, each room should only be visited once. Thus, not all doors should be opened for all rooms to be counted. A door on one side of the wall may be closed even if the room on the other side has been visited, depending on the path taken by the robot. To make sure that each room is only visited once, the robot should check the `visited` status of the room on the other side of a closed door before choosing to open the door. The door should only be opened if the room on the other side has `visited: false`. Otherwise, it should carry on with the wall in the next direction. 


## Defining the robot's actions

The robot keeps track of the following variables:

```
currentLocation = [column, row] 
roomCount = INTEGER
```

The `currentLocation` variable starts at the coordinates of robot at the start of the game. `roomCount` starts at `1` to represent the room the robot starts in. 

The robot has a function `checkWalls` which determines whether the robot can/should move to an adjacent room, and moves into it, incrementing the `roomCount` variable.

Looping through the directions (N,S,E,W) can be done with a simple for loop, and the overall room checking and counting process can be done recursively.

NOTE: when the status of one wall of a room is changed from closed to open, the same change must be applied to the adjacent room on the other side of the door. For example if the robot has just opened the North door of a room and moved into the next room, the new room's South door must now be marked as opened.

